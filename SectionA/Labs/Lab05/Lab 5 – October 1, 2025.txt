Lab 5 – October 1, 2025

In this lab you will design and implement, from scratch, a city-wide cinema management system in Java that mirrors a realistic multi-level domain model and exercises arrays, encapsulation, enums, and object collaboration. Your system will revolve around four core entities, Seat, Screen, Cinema, and CityCinema, and two demo drivers. The heart of the model begins at the Seat level: an individual seat is identified by a human-friendly ID like row-col (for example, 3-007) and classified using a type-safe enumeration (REGULAR, PREMIUM, VIP, RECLINER) rather than ad-hoc strings. Each seat stores its price and availability and exposes behavior to transition safely between states, such as booking and canceling a booking, while its toString() provides a concise, readable snapshot for logs and reports. Building upward, a Screen represents a physical auditorium with a jagged 2D array of Seat objects (for instance, five rows whose lengths increase as 10, 11, 12, 13, 14). When a screen is constructed, it should automatically materialize its seat grid, assign seat types by policy (for example, front rows as REGULAR, middle rows as PREMIUM, penultimate rows as VIP, and the last row as RECLINER), and derive prices from type so that your model demonstrates both structure and behavior without manual, error-prone setup. The screen must support practical operations that a booking desk would expect: locating seats by ID or by coordinates, booking and canceling, counting total and available seats overall and by type, listing or finding the first available seat that matches a requested type, and rendering the seating plan as a compact layout view (showing each seat with an availability marker) or a verbose listing for auditing.

Above the screens sits the Cinema, which aggregates multiple Screen instances under a branch name and acts as a façade for higher-level workflows. A cinema can be constructed with a predetermined number of screens using default layouts (to showcase array preloading) or built incrementally by adding named screens with custom row configurations. It should delegate booking and canceling by screen name or index and seat ID ("Screen-2", "3-007"), compute aggregate statistics such as total versus available seats (both overall and per SeatType), and provide coherent reports that iterate through each screen’s layout or detailed seat list. The Cinema’s toString() should summarize its state in a single line suitable for dashboards and logs. At the top of the model, CityCinema coordinates many Cinema branches within a named city. It must let you add or remove cinemas, search for a cinema by name, relay booking and cancel operations down to the appropriate screen, and compute city-wide aggregates. To make discovery tasks straightforward, it should also support convenience queries such as “find the first available VIP seat in this city” and produce city summaries that roll up totals from all branches. While List can be used internally for ergonomic management, the lab explicitly requires demonstrating array-based preloading: provide a city method that initializes a fixed array of cinemas (each preloading an array of screens, each preloading arrays of seats) and then integrates that data into your collections so that the program never starts empty.

Your demonstration should reflect a realistic Pakistani deployment from the first line of main. In ScreenDemo (or CinemaDemo), the program should begin by constructing CityCinema objects for at least Karachi, Lahore, and Islamabad, each preloaded with multiple cinemas and screens so that output appears immediately with no user input. After printing compact layouts for each city to the console, simulate a series of typical operations: book a specific seat by ID (for example, in Karachi → “Cinema-1” → “Screen-1” → 3-007), attempt to double-book the same seat to demonstrate validation, cancel the booking, and then re-display the affected layouts to show state transitions. Also include a small search scenario, for instance, locate and print the first available VIP seat in Lahore,so students exercise list/filter logic. Separately, provide a SeatDemo that focuses purely on the Seat API in isolation: instantiate several seats of different types, verify default availability, perform bookings and cancellations, adjust prices where relevant, and print the results with toString() to confirm that the enum/type/price triad behaves as intended. Throughout your demos, favor method calls over ad-hoc printing: let displayLayout, displayVerbose, book, cancel, getAvailableSeatCount (with and without SeatType), and searches speak for the model rather than reproducing their internals in main.

A key deliverable of this lab is data that is visible at startup. When each program runs, it must load already created data into arrays, for example, create an array of Cinema objects for a city, with each Cinema preloading a fixed array of Screen objects (using jagged row arrays), and each Screen materializing a 2D array of Seat objects. Only after this array-backed bootstrap should your code layer on any dynamic behavior. This ensures your submission demonstrates not only clean object design but also disciplined initialization using arrays, realistic defaults (type and price policies), and robust behavior under booking workflows. By the end of Lab 5, your system should model multiple Pakistani cities, each with several cinemas, each cinema with several screens, and each screen with a heterogeneous seat map; it should accept bookings and cancellations by seat ID, surface availability and pricing insights at every level, and present clear, human-readable layouts and summaries that prove the correctness of your implementation.

Required classes for this lab:
Seat (enum-backed type, price, availability, booking/cancel, readable toString());
Screen (jagged 2D seat array, type/price policy, booking/cancel by ID or coordinates, counts, search, displayLayout and detailed display);
Cinema (named branch, multiple screens, add/find screens, booking/cancel delegation, aggregates and reports);
CityCinema (named city, multiple cinemas, add/find/remove, city-wide aggregates, first-available search, and array-based preload of cinemas/screens/seats);
SeatDemo (unit-style exercises for Seat features);
ScreenDemo or CinemaDemo (initializes Karachi, Lahore, Islamabad with preloaded arrays, prints layouts, performs booking/cancel flows, and demonstrates search/reporting).