Lab 4
Task
Date: September 24, 2025

In this lab, students will design and implement a simple Card Game Application using Java. The purpose of this exercise is to strengthen understanding of OOP concepts such as classes, objects, constructors, enumerations, arrays, encapsulation, and object composition. By the end of this lab, students will have developed a playable card game in which multiple players compete by drawing cards from a shuffled deck.

Scenario

The game begins with a standard deck of 52 playing cards. Each card has a suit (Spades, Hearts, Diamonds, Clubs) and a rank (Ace through King). At the start of the game, the deck is created, displayed, and then shuffled to ensure randomness. Players are then created, and each is dealt a certain number of cards from the deck. In each round, every player reveals one card from their hand; the round winner is the player who revealed the highest-ranked card based on the rank ordering defined in the program. The game proceeds for a fixed number of rounds (typically equal to the number of cards dealt to each player). When all rounds are complete, the player with the most round wins is declared the overall winner. This simplified card game allows students to practice dividing a problem into modular classes and understand how objects interact to form a working program.

Class Requirements
The Card class represents a single playing card composed of a suit and a rank. It should be immutable after construction and provide accessors for suit and rank as well as a readable toString representation such as “Ace of Spades”. The Suit class is implemented as an enum containing the four suits with a short symbol if desired; the Rank class is another enum representing the thirteen ranks in their natural order, optionally carrying an integer value to support comparisons. The Deck class models a full 52-card deck. Its constructor must populate all suit–rank combinations. It should provide a shuffle method to randomize order and a draw method that removes and returns the top card. It may also offer convenience operations such as size, isEmpty, and deal which draws and returns an array or list of N cards for a player. The Demo class contains the main method responsible for constructing a Game instance with a chosen number of players and cards per player, starting the game, and printing a concise play-by-play to the console so the result is visible and testable.

Player class (required behavior and methods)
The Player class models one participant and encapsulates their identity and hand. Each Player must have a name and an internal collection to hold their cards. A constructor should accept at least the player’s name and, optionally, an initial capacity or a starting hand. The addCard method appends a dealt card to the player’s hand. To participate in a round, the playCard method removes and returns one card to be revealed; the simplest policy is to play the “next” card (for example, the first card in the hand), but students may choose more sophisticated strategies later. For visibility and debugging, the showHand method returns a string representation of the current hand without modifying it. The handSize method returns the count of cards currently held, while the isOut method returns true when the player has no cards left to play. To support scoring variants, the calculateScore method should compute a numeric score from the player’s hand (for example, summing rank values) even though the default round-based game does not require it; this method is useful for extensions and for tie-breakers if two players win the same number of rounds. Accessors such as getName and (optionally) setName should be present, and toString should return a readable description like “Player Alice (5 cards)”. Internally, students should ensure the Player class does not expose its hand for uncontrolled mutation; adding cards and playing cards must go through the provided methods to preserve encapsulation.

Game class (required behavior and methods)
The Game class coordinates the entire flow: setup, dealing, rounds, and winner determination. A constructor should accept the number of players and the number of cards to deal per player, construct a fresh Deck, create the Player objects, and prepare internal state such as the current round counter and a scoreboard mapping each player to the number of rounds they have won. The initialize method should handle deck creation (if not already created), perform a shuffle, and reset all scores and round counters to start conditions. The deal method must iterate over players in round-robin fashion and call addCard on each Player until each has the required number of cards, drawing from the Deck each time; it should validate that the deck contains enough cards for the requested configuration and throw or report an error if not. The playRound method advances a single round of play: it asks each Player to playCard, prints or records each revealed card, determines the highest card according to Rank ordering, and increments the winner’s score; if two or more cards share the same highest rank, the method should apply a clear tie policy—either declare the round a draw with no points, or break ties by suit order as defined in Suit (this policy must be consistent and documented in the code comments). The compareCards helper should encapsulate the comparison logic so that alternative rules (for example, Ace-high vs Ace-low) can be swapped without changing round control flow. The playAll method (or start) runs playRound repeatedly until the configured number of rounds has been completed or all players have no cards left. The determineWinner method evaluates the scoreboard at the end of the game and returns the Player who has the most round wins; in the case of a total tie, it may apply a secondary rule such as higher sum from calculateScore or simply report “tie game.” Utility methods such as getCurrentRound, isOver, getScoreboardString, and reset are encouraged to improve testability and user feedback. Throughout, the Game class should be responsible for user-visible logging (for example, printing the dealt hands at the start, showing each round’s plays and the current standings), while keeping the Player class logic focused on card management, not I/O.

By completing this lab, students will gain practical experience in designing a modular Java application where multiple classes interact to create a complete program. The final output should demonstrate the entire game process: creating and shuffling a deck, dealing cards to each player, playing the configured number of rounds with clear, consistent comparison rules, and printing the final standings and overall winner.

Required Classes

Card
Suit
Rank
Deck
Player
Game
Demo