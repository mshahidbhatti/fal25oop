Lab 5 – October 3, 2025

In this lab you will design and implement, from scratch and using only Java arrays, a city-wide cinema management system that practices encapsulation, enums, array indexing, and multi-class collaboration. Your model has four core entities, Seat, Screen, Cinema, and CityCinema, plus two demo drivers. At the foundation, a Seat represents a single chair identified by a human-friendly ID in the form row-col such as 3-007. Seat must use a type-safe enumeration for classification (REGULAR, PREMIUM, VIP, RECLINER), store a price, track availability, and provide safe state changes through methods that book and cancel a booking. Its toString should present a short summary with ID, type, price, and availability.

A Screen is a physical auditorium backed by a jagged two-dimensional Seat array. A simple default is five rows whose lengths increase as 10, 11, 12, 13, 14. When a Screen is constructed it must materialize the entire grid, assign seat types by a clear policy (front rows REGULAR, middle rows PREMIUM, penultimate rows VIP, last row RECLINER), and derive prices from type so the system demonstrates both structure and behavior without manual per-seat setup. Use a pricing policy that is visible in output and easy to verify: REGULAR 500 PKR, PREMIUM 750 PKR, VIP 1000 PKR, RECLINER 1200 PKR. Screen must locate a seat by ID or by coordinates, book and cancel seats, count total and available seats overall and by type, and provide two displays: a compact layout view that shows each seat with an availability marker and a detailed listing that prints every seat using toString. Whenever a method needs to return multiple seats, return a plain Seat[] built with the classic two-pass technique: first count matches, then allocate an array of that size and fill it.

A Cinema aggregates several Screen instances under a branch name using a plain Screen[] plus a logical size counter. Because collections are not used, grow capacity manually by allocating a larger array and copying elements when needed. Support construction with a fixed number of default Screens to showcase array-based preloading, plus operations to add a named Screen with custom row lengths, find a Screen by name or by index, forward booking and cancellation to a particular screen and seat ID, compute totals and availability overall and by SeatType, and print clear reports that iterate through each screen’s layout or detailed list. The Cinema toString should compress its state into a single readable line that includes name, number of screens, total seats, and available seats.

CityCinema coordinates many Cinema branches within a named city using the same arrays-only approach: maintain a Cinema[] with a logical size, grow it manually, and provide methods to add and remove cinemas, find a cinema by name, relay booking and cancellation requests down to the correct cinema and screen, and compute city-wide aggregates. Include a discovery helper that scans the city for the first available VIP seat and returns a human-friendly description such as Cinema-2 > Screen-1 > Seat 3-007 (VIP, 1000.00 PKR). If you need to return multiple results, expose them as arrays rather than collections. Provide a city preload method that builds a fixed array of cinemas, each with a fixed array of screens, each screen materializing a two-dimensional seat array, so the program never starts empty.

Your demonstration must feel like a real Pakistani deployment from the first line of main. In ScreenDemo or CinemaDemo, begin by building CityCinema objects for Karachi, Lahore, and Islamabad, all preloaded strictly through arrays. Use realistic example names to make the output readable, such as Atrium Saddar and Nueplex DHA in Karachi, CineStar Township and CineStar Gulberg in Lahore, and Centaurus Megaplex in Islamabad. Print compact layouts for each city, then simulate a typical workflow: book seat 3-007 in Karachi at Cinema-1 on Screen-1, attempt to book the same seat again to show correct rejection, cancel the booking, and print the affected layouts again to confirm the state change. Add a small search task that prints the first available VIP seat in Lahore. Separately, write SeatDemo that focuses only on Seat: construct a few seats of different types, verify that new seats are available by default, perform bookings and cancellations, adjust a price where appropriate, and print results with toString so that the enum, price, and availability logic is obvious.

A key deliverable is data that is visible at startup. Each program must load already created data using arrays: for each city, create a fixed array of Cinema objects; each Cinema preloads a fixed array of Screen objects using jagged row arrays; each Screen materializes a two-dimensional Seat array and assigns types and prices according to the stated policy (REGULAR 500 PKR, PREMIUM 750 PKR, VIP 1000 PKR, RECLINER 1200 PKR). First, create the starting data using arrays (cities, cinemas, screens, seats). After that, add code for actions like booking and canceling seats. By the end of Lab 5, your program should handle several Pakistani cities. Each city should have multiple cinemas, each cinema should have multiple screens, and each screen should have seats of different types and prices. The program must let you book and cancel by seat ID, show how many seats are available and their prices at each level, and print clear layouts and summaries. Do all of this using only arrays (no Java Collections).

You must submit the following classes: Seat, Screen, Cinema, CityCinema, SeatDemo, and ScreenDemo or CinemaDemo.